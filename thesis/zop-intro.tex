Program profiling is a type of dynamic analysis that measures some aspects of software behavior. One of the most common instances of program profiling counts the execution of instructions or sequences of instructions and uses that information to identify heavily executed paths (also called \textit{hot paths}). Knowledge of the hot paths can guide other tasks such as code optimization and performance analysis. Profiling is typically implemented by adding software probes (instrumentation) to a program's source code or binary executable and these probes either log events of interest or update statistics about such events at runtime.

%after deployed, don't want to change code
This approach is effective in many usage scenarios, but there are a few exceptions. Adding instrumentation unavoidably adds runtime and resource overheads. Runtime overheads can alter the timing of events, and so in real-time systems or cyber-physical systems these timing changes can affect the path taken through the profiled program.  In fact, if overheads are high enough, these systems may fail (\eg miss real-time deadlines) if they are profiled under ``in the field'' conditions. Profiling is also challenging in already deployed software~\cite{kraft2010}, where a deployed system that suffers performance problems would ideally be profiled \textit{in situ} to ensure that the profiling results capture the actual program behavior in that deployment. Although hardware features can reduce the software overhead required for detailed profiling, they can rarely eliminate it completely. Moreover, these solutions are costly in terms of chip/PCB space and development time, and feature support varies between devices.  Profiling embedded controllers presents additional challenges, as these devices often lack sufficient memory space to store the extra code (instrumentation) and profiling-related data structures. They also sometimes lack the I/O interfaces to report the profiling results back to the programmer.

An ideal profiling solution would be one that gathers (1) perfectly accurate information about what is actually executed during profiling (2) without changing anything about the profiled system: no code instrumentation, no data structures for profiling information, no additional I/O activity, and no changes to the hardware of the system. While instrumentation can provide perfectly accurate profiling information, it is an inherently intrusive technique that---even when minimal and designed so as not to affect the semantics of the instrumented code---changes some important aspects of the code's dynamic behavior.

These properties make program profiling an attractive target application for software analysis via EM emanations. This chapter proposes \zop\ (Zero-Overhead Profiling), a technique that retains the second aspect of ideal profiling (no changes to the profiled code or system) at the cost of less-than-perfect accuracy. \zop\ computes profiling information in a highly accurate and completely non-intrusive way by leveraging electromagnetic (EM) emanations generated by a system as the system executes code. Because \zop\ generates profiling information without interacting with or modifying the profiled system, it offers the potential to profile a variety of software systems for which profiling was previously not possible. In addition, the ability to collect profiles by simply placing a profiling device next to the system to be profiled can provide advantages over traditional instrumentation-based approaches in many traditional contexts as well.

\zop\ first measures the EM emanations produced by the system to be profiled as the system processes inputs whose execution path is known (\textit{training} phase). This allows \zop\ to build a model of the waveforms produced by different code fragments. \zop\ then collects emanations from a new, unknown execution and infers which parts of the code are being executed at which times (\textit{profiling} phase). This inference is accomplished by matching the observed unknown emanations to emanations from the training phase that are known to be generated by particular code fragments.

This chapter presents:
\begin{itemize}
\item \zop, a completely non-invasive profiling approach, where profile information is inferred from EM emanations of the (unmodified) system as it runs the (unmodified) to-be-profiled software.
\item A proof-of-concept implementation of \zop\ that shows that our approach is practically feasible.
\item Experimental results that (1) show that \zop\ can achieve high profiling accuracy and (2) provide insight into the performance of \zop\ that suggest directions for further research.
\end{itemize}

In the rest of the chapter, Section~\ref{zop-background} describes at a high level how program execution can be related to EM emanations, Section~\ref{sec:approach} describes how \zop\ generates a training model and uses EM emanations along with this training model to generate profiling data for new program executions, and Section~\ref{sec:evaluation} describes an implementation and experimental evaluation of \zop.
